
- Transport layer provides communication between application processing running on different hosts
- How two entities communicate without losing or corrupting data
- Controlling the transmission rate of transport-layer entities in order to avoid, or recover from, congestion within the network
## Introduction and Transport-Layer Services

- A transport layer protocol provides logical communication between application processes running on different hosts
- Transport-layer protocols are implemented in end systems, but not in network routers
- Convert the application-layer message into transport-layer packets, known as segments
- Network routers do not examine the fields of the transport-layer segment encapsulated on the datagram

<img src="/images/Pasted image 20251215002503.png" alt="image" width="500">

### Relationship Between Transport and Network Layers

- Transport layer protocols provides logical communication between processes running on different hosts
	- Lives in the end systems
	- Does not interact with intermediate routers
	- Offers reliable data transfer, even if network is unreliable
	- Use encryption, even if network layer cannot guarantee the confidentiality
- A network-layer protocol provides logical communication between hosts

### Overview of the Transport Layer in the Internet

- Internet literature also refers to the transport-layer packet for TCP as a segment, but datagram for UDP
- Also uses datagram for network layer packet
- IP provides logical communication between hosts
- IP service model is a best-effort delivery service
	- No guarantees
- IP is an unreliable service
- The fundamental responsibility of UDP and TCP is to extend IP's deliver service between two end systems to two processes running on the end systems,
	- Host-to-host, delivery to process-to-process delivery is known as transport-layer multiplexing or demultiplexing
- Integrity checking by including error-detection fields in segment headers
- UDP
	- Process-to-process
	- Error checking
- TCP
	- Reliable data transfer
	- Provides congestion control

## Multiplexing and Demultiplexing

- Transport layer receives segments from the network layer below
- Needs to deliver data segments to application process on host
- A process can have one or more sockets
- Transport layer does not deliver the data directly, instead to an intermediary socket
- Each socket has a unique identifier
- Delivering data to correct socket is called demultiplexing
- Job of gathering data chunks at source from different sockets, encapsulating each with header information to create segments, and passing to the network layer is called multiplexing

<img src="/images/Pasted image 20251215003847.png" alt="image" width="500">

- Transport layer in the middle must also gather outgoing data from sockets

- Transport multiplexing
	- Sockets have unique identifiers
	- Each segment has special fields that indicate socket destination
		- Source port number
		- Destination port number
	- Each port is 16 bits
- Port 0 to 1023 are well-known port numbers and restricted

<img src="/images/Pasted image 20251215004126.png" alt="image" width="500">

- Transport layer could implement demultiplexing service
- Multiplexing/demultiplexing in TCP is more stable

**Connectionless Multiplexing and Demultiplexing**
- Transport layer assigns a port number to a socket
- Transport layer in Host A creates a transport-layer segment that includes the application data, source port number, destination port number, and two other values
- This is passed to network layer, and delivers to receiving host
- UDP segments have different source IP addresses and/or source port numbers, but have the same destination IP and port

<img src="/images/Pasted image 20251215004616.png" alt="image" width="500">

**Connection-Oriented Multiplexing and Demultiplexing**
- TCP socket is identified by a 4-tuple
	- Source IP
	- Source port
	- Destination IP
	- Destination port
- two arriving TCP segments with different source IP will be directed to two different sockets
- TCP server application has a "welcoming socket"
- TCP client creates a socket and sends a connection

```python
clientSocket = socket(AF_INET, SOCK_STREAM)
clientSocket.connect((serverName, 12000))
```

- Connection requires nothing more than a TCP segment with a special connection establishment bit

- Server can support many simultaneous TCP connection sockets

#### PORT SCANNING

- For TCP, nmap sequentially scans ports, looking for ports that are accepting TCP connections
- For UDP, nmap sequentially scans ports, looking for UDP ports that respond to transmitted UDP segments

- Both, return a list of open, closed, or unreachable ports

<img src="/images/Pasted image 20251215005107.png" alt="image" width="500">

- Host C initiates two HTTP sessions to server B, and Host A initiates one HTTP session to B
- Host C assigned two different source port numbers
- Host A might choose the same source port as C
- Server B will still be able to correctly demultiplex the two, since the connections have different source IP addresses

**Web Servers and TCP**
- All segments have the destination port 80
- Web servers often use only one process, and create a new thread with a new connection socket for each new client connection
- In persistent HTTP
	- Connection and server exchange via the same server socket
- In non-persistent HTTP
	- New TCP connection is created and closed for every request/response

## Connectionless Transport: UDP

- Application developers choose UDP instead of TCP, then the application is almost directly taking with them
- UDP is connectionless, since there is no handshaking required
- DNS uses UDP

UDP over TCP
- Finer application-level control over what data is sent, and when
- No connection establishment
- No connection state
- Small packet header overhead

<img src="/images/Pasted image 20251215005911.png" alt="image" width="500">

- Both UDP and TCP are used with multimedia applications
	- Real time video react poorly to TCP's congestion control
- QUIC protocol used in Google's Chrome browser implements reliability in an application-layer protocol on top of UDP

### UDP Segment Structure

- Application data occupies the data field of the UDP segment
- UDP headers have 4 fields, consisting of two bytes
- Checksum is used by receiving host to verify the data

<img src="/images/Pasted image 20251215010224.png" alt="image" width="500">
### UDP Checksum

- Checksum determines whether bits within the UDP segment have been altered
- Sender performs 1s complement of the sum of all 16-bit words in the segment

<img src="/images/Pasted image 20251215010419.png" alt="image" width="500">

- Last addition had overflow, which was wrapped around
- End-end principle in system design, which states that since certain functionality must be implemented on an end-end basis

## Principles and Reliable Data Transfer

- With a reliable channel, no transferred data bits are corrupted or lost
- Reliable data transfer protocol to implement this service abstraction
- TCP is a reliable data transfer protocol that is implemented on top of an unreliable (IP) end-to-end network layer

<img src="/images/Pasted image 20251215010840.png" alt="image" width="500">

- Assume that packets will be delivered in the order that they are send
- Sending side, will pass data to upper layer
- Only consider the case of unidirectional data transfer
	- Data from sending to receiving side
- Reliable bidirectional (full-duplex) data transfer is no more difficult

### Building a Reliable Data Transfer Protocol

**Reliable Data Transfer over a Perfectly Reliable Channel: `rtd1.0`**
- The finite-state machine (FSM) definition for the `rtd1.0` sender and receiver
- No packet loss, not bit errors, and no reordring

<img src="/images/Pasted image 20251215011257.png" alt="image" width="500">

**Reliable Data Transfer over a Channel with Bit Errors: `rdt2.0**
- More realistic model of underlying channel is one in which bits in a packet may be corrupted
- Introduces checksums and ACK/NAK feedback so sender can retransmit corrupted packets
- Message-dictation protocol uses both positive and negative acknowledgements
- Retransmission protocols are also known as AQR (Automatic Repeat reQuest) protocols
	- Error detection
	- Receiver feedback
	- Retransmission

<img src="/images/Pasted image 20251215011714.png" alt="image" width="500">




- ACK or NAK packet could be corrupted
- Cannot recover from errors in ACK and NAK packets
	- Ask for a replay
	- Add checksum to recover from bit errors
	- Sender to resend current data packet
		- Introduces duplicate packets

- A simple solution is to add a new fields by putting a sequence number in this field

**`rtd2.1`**

- Adds sequence number (0 and 1) so the sender and receiver can detect duplicates

<img src="/images/Pasted image 20251215011946.png" alt="image" width="500">

<img src="/images/Pasted image 20251215012001.png" alt="image" width="500">

**`rtd2.2`**
- NAKs are removed
- Relies on ACKs with sequence numbers

<img src="/images/Pasted image 20251215012105.png" alt="image" width="500">



<img src="/images/Pasted image 20251215012049.png" alt="image" width="500">


**Reliable Data Transfer over a Lossy Channel with Bit Errors, `rdt3.0`**

- Complete reliable data transfer that can have bit errors and packet loss
- Time-based retransmission mechanism requires a countdown time that can interrupt the sender
- Sender
	- Starts the timer for each packets
	- Repsonds to a timer interrupt
	- Stops the timer
- `rtd3.0` is sometimes referred to as the alternating-bit protocol using 0 and 1s

<img src="/images/Pasted image 20251215012410.png" alt="image" width="500">



### Pipelined Reliable Data Transfer Protocols

- Problem with `rtd3.0` is the stop-and-wait protocol

<img src="/images/Pasted image 20251215012824.png" alt="image" width="500">
<img src="/images/Pasted image 20251215012836.png" alt="image" width="500">
<img src="/images/Pasted image 20251215012851.png" alt="image" width="500">

<img src="/images/Pasted image 20251215012938.png" alt="image" width="500">

- Rather than operate in a stop-and-wait manner, the sender is allowed to send multiple packets without waiting for acknowledgements
- This is known as pipelining
	- Range of sequence numbers must be increased
	- Sender and receiver sides of the protocol may have to buffer more than one packet
	- Range of sequence numbers needed and buffering requirements depend on data transport protocol
		- Go-Back-N
		- Selective repeat

### Go-Back-N (GBN)

- Sender is allowed to transport multiple packets
- Constrained to a max

<img src="/images/Pasted image 20251215013223.png" alt="image" width="500">

- $N$ is referred to as the window size, and the GBN protocol is a sliding-window protocol
- Flow control is one reason to impose a limit on the sender


<img src="/images/Pasted image 20251215013400.png" alt="image" width="500">

- Sender can have up to N unacknowledged packets in flight
- Receiver only accepts packets in order
- ACKs are cumulative
- Loss or timeout, sender must retransmit all unACKed packets

GBN sender must respond to 3 types of events
- Invocation from above
- Receipt of an ACK
- A timeout event

- Event-based programming, procedures are called (invoked) by other procedures in the stack, or are interrupted

<img src="/images/Pasted image 20251215013725.png" alt="image" width="500">



### Selective Repeat (SR)

- The GBN protocol allows the sender to fill the pipeline with packets
- GBN suffers from performance problems, when there is a single packer error causes GBN to retransmit a large number of packets
- Selective-repeat protocols avoid unnecessary transmission by having the sender retransmit only those packets that it suspects were received in error at the receiver
- Receiver individually acknowledges correctly received packets
- SR receiver will acknowledge a correctly received packet whether or not it is in order
- Out-of-order packets are buffered until any missing packets are received
- Window $N$ limits the size of the outstanding packets in the pipeline

<img src="/images/Pasted image 20251216115950.png" alt="image" width="500">

**SR Sender Events and Actions**
1. Data received from above
	1. Checks the next available sequence number for the packet
2. Timeout
	1. Timers are used to protect against lost packets
	2. Each packet has a local timer
3. ACK received
	1. SR sender marks packet as being received

**SR Receiver Events and Actions**

- Packet with sequence number in `[rcv_base, rcv_base+N-1]` correctly received
- Packet with sequence number in `[rcv_base-N, rcv_base-1]` is correctly received
- Otherwise
	- Ignore packet

<img src="/images/Pasted image 20251216120348.png" alt="image" width="500">

- The sender and receiver will not always have an identical view of what has been received correctly

<img src="/images/Pasted image 20251216120518.png" alt="image" width="500">

A
- The ACKs for the first three packets are lost and the sender retransmits these packets
- The receiver next receives a packet with sequence number 0, a copy of the first packet sent

B
- ACKs for the first three packets are all delivered correctly
- Sender moves its window forward and send the next packets'

- For the receiver the two process are identical
- Packets cannot live in the network for longer than some fixed maximum amount of time
	- 3 minutes in the TCP extensions for high-speed networks


**Checksum**
- Used to detect bit errors in transmitted packets

**Timer**
- Used to timeout/retransmit packets
- Occur when a packet is delayed but not lost
- Or when packet has been received but there is no ACK

**Sequence Numbers**
- Used for sequential numbering of packets of data flowing from sender to receiver
- Gaps in the sequence allow receiver to detect a lost packet
- Packets with duplicate numbers allow the receiver to detect duplicate copies

**Acknowledgement**
- Used by the receiver to tell the sender that a packet or set of packets has been received correctly
- Carries sequence numbers of packets or packets being acknowledged
- Individual or cumulative

**Negative Acknowledgement**
- Used by the receiver to tell the sender that a packet has not been received correctly

**Window, Pipelining**
- Sender restricts only packets with sequence numbers that fall in a given range to be sent
- Sender utilization can be increased over a stop-and-wait mode of operation
- Window size is set on the basis of receivers ability to receiver and buffer messages, or the level of congestion in the network

## Connection-Oriented Transport (TCP)

- TCP relies on error detection, retransmissions, cumulative acknowledgements, timers, and header fields for sequence and acknowledgement numbers

### The TCP Connection

- TCP is connection oriented because before one application process can begin to send data to another, the two processes must first handshake with each other
- The TCP connection is not an end-to-end TDM or FDM
- Instead, the connection is a logical one, with common state residing only in the TCPs in the two communicating end systems
- Intermediate routers are completely oblivious to TCP connections
- TCP provides a full-duplex service
- A TCP connection is always point-to-point
- Multicasting
	- Transfer of data from one sender to may receivers in a single send operation is not possible

#### Vinton Cerf, Robert Kahn, and TCP/IP

- 1970s, packet switched networks began to proliferate

`clientSocket.connect((serverName, serverPort))`

- The first two segments carry no payload, no application-layer data
- The third segments may carry a payload
	- Three-way handshake
- TCP directs this data to the connection's send buffer, which is one of the buffers that is set aside during the initial three-way handshake
- TCP will grab chunks of data from the buffer and pass it to the network layer
- The max amount of data grabbed and placed in a segment is the maximum segment size (MSS)
- MSS is set by first determining the length of the largest link-layer frame called maximum transmission unit (MTU)
- TCP pairs each chunk of client data with a TCP header, forming a TCP segment
- Segments are passed down to the network layer, and encapsulated within network-layer IP datagrams
- TCP receives a segment at the other end, and placed into the receive buffer

<img src="/images/Pasted image 20251216151336.png" alt="image" width="500">

- Each side of the connection has its own send and receive buffer
- TCP connection consists of buffers, variables, and socket connection

### TCP Segment Structure

- TCP segment consists of header fields and data fields

- TCP data field
	- Data field contains a chunk of application data
	- TCP breaks the file into chunks of size MSS

- TCP header
	- 32-bit sequence number field
	- 32-bit acknowledgement number field
	- 16-bit receive window
	- 4-bit header length field
	- Option field
	- Flag field
		- ACK bit
		- RST
		- SYN
		- FIN

- Location of the last bytes of this urgent data is indicated by 16-bit data pointer field

<img src="/images/Pasted image 20251216151728.png" alt="image" width="500">


- UDP
	- Header includes source and destination port numbers
	- Header also includes checksum field


**Sequence Numbers and Acknowledgment Numbers**

- TCP views data as an unstructured, but ordered, stream of bytes
- The sequence number for a segment is the byte-stream number of the first byte in the segment
- The acknowledgement number is the sequence number of the next byte Host A is expecting from Host B
- TCP provides cumulative acknowledgements
	- TCP only acknowledges bytes up to the first missing byte in the stream

<img src="/images/Pasted image 20251216152744.png" alt="image" width="500">

- TCP RFCs does not impose any rules here and leave the decision up to the programmers implementing a TCP implementation
	- Receiver immediately discards out-of-order segments
	- The receiver keeps the out-of-order bytes and waits for the missing bytes to fill in the gaps

- Both sides of a TCP connection choose a initial sequence numbers

**Telnet: Sequence and Acknowledgement Numbers**
- Popular application-layer protocol used for remote login
- Users now prefer to use SSH protocol, since data sent in a Telnet connection are not encrypted

<img src="/images/Pasted image 20251216153111.png" alt="image" width="500">

- The acknowledgement for client-to-server data is carried in a segment carrying server-to-client data
	- Known as piggybacked on the server-to-client data segment


### Round-Trip Time Estimation and Timeout

- TCP uses a timeout/retransmit mechanism to recover from lost segments
- Timeout should be larger than the connection's round-trip time (RTT)

**Estimating the Round-Trip Time**
- Most TCP implementations take only one RTT measurement at a time
- TCP never computes a RTT for a segment that has been retransmitted
- RTT will fluctuate from segment due to congestion in routers and varying load on the end systems
- TCP maintains an average RTT value

`EstimatedRTT=(1−α)EstimatedRTT+αSampleRTT`

- The new value of `EstimatedRTT` is a weighted combination of the previous value of `EstimatdRTT` and the new value for `SampleRTT`
- The recommended value of α = 0.125
- Average is called an exponential weighted moving average (EWMA)

#### Principles in Practice

- TCP also uses pipelining, allowing the sender to have multiple transmitted but yet-to-be acknowledged segments outstanding

### Reliable Data Transfer

- The network layer (IP service) is unreliable
- IP does not guarantee the integrity of the data in the datagrams
- Datagrams can overflow router buffers and never reach their destination
	- Arrive out of order
	- Bits in datagram can get corrupted
- TCP creates a reliable data transfer service on top of IP's unreliable best-effort service
- The recommended TCP timer management procedure uses only a single retransmission timer

```python
// TCP sender
// Data received from application above, timer timeout, and ACK

NextSeqNum = IntitialSeqNumber
SendBase = InitialSeqNumber

loop (forever){
	switch(event)
	
	event: data received from application above
		create TCP segment with sequence number NextSeqNum
		if (timer currently not running)
			start timer
		pass segment to IP
		NextSeqNum=NextSeqNum+length(data)
		break;
		
	event: timer timeout
		retransmit bot-yet-acknowledged segment with
			smallest sequence number
		start timer
		break;
		
	event: ACK received, with ACK field value of y
		if (y < SendBase){
			SendBase=y
			if (there are currently any not-yet-acknowledged segments)
				start timer
		}
	break;
}
```

- Timer is associated with the oldest unacknowledged segment
- TCP responds to the timeout event by retransmitting the segment that cause the timeout
- TCP then restarts timer


**A Few Interesting Scenarios**

- The acknowledgement from A to B gets lost
- Timeout event occurs, and Host A retransmits the same segment
- TCP in host B will discard the bytes in the retransmitted segment

<img src="/images/Pasted image 20251216202610.png" alt="image" width="500">

- Both segments arrive at B
- Neither of the acknowledgements arrive at Host A before the timeout
- Host A resends the first segment and restarts the timer
- As long as the ACK for the second segment arrives before the new timeout, the second segment will not be retransmitted

<img src="/images/Pasted image 20251216202711.png" alt="image" width="500">

- Host A knowns that Host B has received everything though byte 119
- Host A does not resend either of the two segments

<img src="/images/Pasted image 20251216202856.png" alt="image" width="500">


**Doubling the Timeout Interval**

- Length of the timeout interval after timer expiration
- TCP retransmits the not-yet-acknowledged segments with the smallest sequence number
- Sets the next timeout interval to twice the previous value
- Intervals grow exponentially after each transmission
- Provides a limited form of congestion control
- In times of congestion, if the sources continue to retransmit the congestion gets worse

**Fast Retransmit**

- Timeout period can be relatively long
- Sender can often detect packet loss before the timeout event occurs by noting duplicate ACKs
- A duplicate ACK is an ACK that re-acknowledges a segment for which the sender has already received an earlier acknowledgement
- If one segment is lost, there will be many back-to-back duplicate ACKs
- The TCP sender performs a fast retransmit

<img src="/images/Pasted image 20251216203453.png" alt="image" width="500">


**Go-Back-N or Selective Repeat**

- TCP looks like GBN-style protocol
- Many TCP implementations will buffer correctly received but out-of-order segments
- A proposed modification to TCP, is selective acknowledgement
	- Allows a TCP receiver to acknowledge out-of-order segments selectively rather than cumulatively acknowledging the last correctly received, in-order segment


### Flow Control

- TCP provides a flow-control service to its applications to eliminate the possibility of the sender overflowing the receiver's buffer
- Flow control is a speed-matching service
- TCP sender cal also be throttled due to congestion within the IP network
- TCP provides flow control by having the sender maintain a variable called the receive window
- Host B tells Host A how much spare room it has in the connection buffer by placing its current value of `rwnd` in the receive window field of every segment it sends to A

<img src="/images/Pasted image 20251217104228.png" alt="image" width="500">

- UDP does not provides flow control
	- Segments may be lost at the receiver due to buffer control

### TCP Connection Management

- TCP connection establishment can significantly add to perceived delays
- SYN flood attack
	- Exploits vulnerabilities in TCP connection management

1. The client side TCP first sends a special TCP segment to the server side TCP
	1. SYN bits is set to 1
	2. Sequence number
2. IP datagram containing the TCP SYN segment arrives at the server host
	1. Allocates TCP buffers and variables to the connection
	2. SYN bits is set to 1
	3. Acknowledgement field (SYNACK segment)
	4. Server chooses its own initial sequence number
3. SYNACK, client also allocates buffers and variables to the connection
	1. Sends acknowledgement of granted connection
	2. SYN bit is set to zero


<img src="/images/Pasted image 20251217104921.png" alt="image" width="500">

<img src="/images/Pasted image 20251217104935.png" alt="image" width="500">

- Client closes connection with FIN bit
<img src="/images/Pasted image 20251217105039.png" alt="image" width="500">

<img src="/images/Pasted image 20251217105058.png" alt="image" width="500">



**The SYN Flood Attack**
- Denial of Service (DoS)attack
- Attacker sends a large number of TCP SYN segments, without completing the 3rd handshake step
- An effective defense is the SYN cookies
	- Creates a half-open TCP connection for this SYN
	- Server sends the client a SYNACK packet with the special initial sequence
	- A legitimate client will return an ACK segment

## Principles of Congestion Control

### The Causes and the Costs of Congestion

- 302

### Approaches to Congestion Control

## TCP Congestion Control

### Fairness

### Explicit Congestion Notification (ECN): Network-assisted Congestion Control

## Summary