
- Transport layer provides communication between application processing running on different hosts
- How two entities communicate without losing or corrupting data
- Controlling the transmission rate of transport-layer entities in order to avoid, or recover from, congestion within the network
## Introduction and Transport-Layer Services

- A transport layer protocol provides logical communication between application processes running on different hosts
- Transport-layer protocols are implemented in end systems, but not in network routers
- Convert the application-layer message into transport-layer packets, known as segments
- Network routers do not examine the fields of the transport-layer segment encapsulated on the datagram

<img src="/images/Pasted image 20251215002503.png" alt="image" width="500">

### Relationship Between Transport and Network Layers

- Transport layer protocols provides logical communication between processes running on different hosts
	- Lives in the end systems
	- Does not interact with intermediate routers
	- Offers reliable data transfer, even if network is unreliable
	- Use encryption, even if network layer cannot guarantee the confidentiality
- A network-layer protocol provides logical communication between hosts

### Overview of the Transport Layer in the Internet

- Internet literature also refers to the transport-layer packet for TCP as a segment, but datagram for UDP
- Also uses datagram for network layer packet
- IP provides logical communication between hosts
- IP service model is a best-effort delivery service
	- No guarantees
- IP is an unreliable service
- The fundamental responsibility of UDP and TCP is to extend IP's deliver service between two end systems to two processes running on the end systems,
	- Host-to-host, delivery to process-to-process delivery is known as transport-layer multiplexing or demultiplexing
- Integrity checking by including error-detection fields in segment headers
- UDP
	- Process-to-process
	- Error checking
- TCP
	- Reliable data transfer
	- Provides congestion control

## Multiplexing and Demultiplexing

- Transport layer receives segments from the network layer below
- Needs to deliver data segments to application process on host
- A process can have one or more sockets
- Transport layer does not deliver the data directly, instead to an intermediary socket
- Each socket has a unique identifier
- Delivering data to correct socket is called demultiplexing
- Job of gathering data chunks at source from different sockets, encapsulating each with header information to create segments, and passing to the network layer is called multiplexing

<img src="/images/Pasted image 20251215003847.png" alt="image" width="500">

- Transport layer in the middle must also gather outgoing data from sockets

- Transport multiplexing
	- Sockets have unique identifiers
	- Each segment has special fields that indicate socket destination
		- Source port number
		- Destination port number
	- Each port is 16 bits
- Port 0 to 1023 are well-known port numbers and restricted

<img src="/images/Pasted image 20251215004126.png" alt="image" width="500">

- Transport layer could implement demultiplexing service
- Multiplexing/demultiplexing in TCP is more stable

**Connectionless Multiplexing and Demultiplexing**
- Transport layer assigns a port number to a socket
- Transport layer in Host A creates a transport-layer segment that includes the application data, source port number, destination port number, and two other values
- This is passed to network layer, and delivers to receiving host
- UDP segments have different source IP addresses and/or source port numbers, but have the same destination IP and port

<img src="/images/Pasted image 20251215004616.png" alt="image" width="500">

**Connection-Oriented Multiplexing and Demultiplexing**
- TCP socket is identified by a 4-tuple
	- Source IP
	- Source port
	- Destination IP
	- Destination port
- two arriving TCP segments with different source IP will be directed to two different sockets
- TCP server application has a "welcoming socket"
- TCP client creates a socket and sends a connection

```python
clientSocket = socket(AF_INET, SOCK_STREAM)
clientSocket.connect((serverName, 12000))
```

- Connection requires nothing more than a TCP segment with a special connection establishment bit

- Server can support many simultaneous TCP connection sockets

#### PORT SCANNING

- For TCP, nmap sequentially scans ports, looking for ports that are accepting TCP connections
- For UDP, nmap sequentially scans ports, looking for UDP ports that respond to transmitted UDP segments

- Both, return a list of open, closed, or unreachable ports

![[Pasted image 20251215005107.png]]

- Host C initiates two HTTP sessions to server B, and Host A initiates one HTTP session to B
- Host C assigned two different source port numbers
- Host A might choose the same source port as C
- Server B will still be able to correctly demult
## Connectionless Transport: UDP

- 

### UDP Segment Structure

### UDP Checksum

## Principles and Reliable Data Transfer

### Building a Reliable Data Transfer Protocol

### Pipelined Reliable Data Transfer Protocols

### Go-Back-N (GBN)

### Selective Repeat (SR)

## Connection-Oriented Transport (TCP)

### The TCP Connection

### TCP Segment Structure

### Round-Trip Time Estimation and Timeout

### Reliable Data Transfer

### Flow Control

### TCP Connection Management

## Principles of Congestion Control


### The Causes and the Costs of Congestion

### Approaches to Congestion Control

## TCP Congestion Control

### Fairness

### Explicit Congestion Notification (ECN): Network-assisted Congestion Control

## Summary