
- Transport layer provides communication between application processing running on different hosts
- How two entities communicate without losing or corrupting data
- Controlling the transmission rate of transport-layer entities in order to avoid, or recover from, congestion within the network
## Introduction and Transport-Layer Services

- A transport layer protocol provides logical communication between application processes running on different hosts
- Transport-layer protocols are implemented in end systems, but not in network routers
- Convert the application-layer message into transport-layer packets, known as segments
- Network routers do not examine the fields of the transport-layer segment encapsulated on the datagram

<img src="/images/Pasted image 20251215002503.png" alt="image" width="500">

### Relationship Between Transport and Network Layers

- Transport layer protocols provides logical communication between processes running on different hosts
	- Lives in the end systems
	- Does not interact with intermediate routers
	- Offers reliable data transfer, even if network is unreliable
	- Use encryption, even if network layer cannot guarantee the confidentiality
- A network-layer protocol provides logical communication between hosts

### Overview of the Transport Layer in the Internet

- Internet literature also refers to the transport-layer packet for TCP as a segment, but datagram for UDP
- Also uses datagram for network layer packet
- IP provides logical communication between hosts
- IP service model is a best-effort delivery service
	- No guarantees
- IP is an unreliable service
- The fundamental responsibility of UDP and TCP is to extend IP's deliver service between two end systems to two processes running on the end systems,
	- Host-to-host, delivery to process-to-process delivery is known as transport-layer multiplexing or demultiplexing
- Integrity checking by including error-detection fields in segment headers
- UDP
	- Process-to-process
	- Error checking
- TCP
	- Reliable data transfer
	- Provides congestion control

## Multiplexing and Demultiplexing

- Transport layer receives segments from the network layer below
- Needs to deliver data segments to application process on host
- A process can have one or more sockets
- Transport layer does not deliver the data directly, instead to an intermediary socket
- Each socket has a unique identifier
- Delivering data to correct socket is called demultiplexing
- Job of gathering data chunks at source from different sockets, encapsulating each with header information to create segments, and passing to the network layer is called multiplexing

<img src="/images/Pasted image 20251215003847.png" alt="image" width="500">

- Transport layer in the middle must also gather outgoing data from sockets

- Transport multiplexing
	- Sockets have unique identifiers
	- Each segment has special fields that indicate socket destination
		- Source port number
		- Destination port number
	- Each port is 16 bits
- Port 0 to 1023 are well-known port numbers and restricted

<img src="/images/Pasted image 20251215004126.png" alt="image" width="500">

- Transport layer could implement demultiplexing service
- Multiplexing/demultiplexing in TCP is more stable

**Connectionless Multiplexing and Demultiplexing**
- Transport layer assigns a port number to a socket
- Transport layer in Host A creates a transport-layer segment that includes the application data, source port number, destination port number, and two other values
- This is passed to network layer, and delivers to receiving host
- UDP segments have different source IP addresses and/or source port numbers, but have the same destination IP and port

<img src="/images/Pasted image 20251215004616.png" alt="image" width="500">

**Connection-Oriented Multiplexing and Demultiplexing**
- TCP socket is identified by a 4-tuple
	- Source IP
	- Source port
	- Destination IP
	- Destination port
- two arriving TCP segments with different source IP will be directed to two different sockets
- TCP server application has a "welcoming socket"
- TCP client creates a socket and sends a connection

```python
clientSocket = socket(AF_INET, SOCK_STREAM)
clientSocket.connect((serverName, 12000))
```

- Connection requires nothing more than a TCP segment with a special connection establishment bit

- Server can support many simultaneous TCP connection sockets

#### PORT SCANNING

- For TCP, nmap sequentially scans ports, looking for ports that are accepting TCP connections
- For UDP, nmap sequentially scans ports, looking for UDP ports that respond to transmitted UDP segments

- Both, return a list of open, closed, or unreachable ports

<img src="/images/Pasted image 20251215005107.png" alt="image" width="500">

- Host C initiates two HTTP sessions to server B, and Host A initiates one HTTP session to B
- Host C assigned two different source port numbers
- Host A might choose the same source port as C
- Server B will still be able to correctly demultiplex the two, since the connections have different source IP addresses

**Web Servers and TCP**
- All segments have the destination port 80
- Web servers often use only one process, and create a new thread with a new connection socket for each new client connection
- In persistent HTTP
	- Connection and server exchange via the same server socket
- In non-persistent HTTP
	- New TCP connection is created and closed for every request/response

## Connectionless Transport: UDP

- Application developers choose UDP instead of TCP, then the application is almost directly taking with them
- UDP is connectionless, since there is no handshaking required
- DNS uses UDP

UDP over TCP
- Finer application-level control over what data is sent, and when
- No connection establishment
- No connection state
- Small packet header overhead

<img src="/images/Pasted image 20251215005911.png" alt="image" width="500">

- Both UDP and TCP are used with multimedia applications
	- Real time video react poorly to TCP's congestion control
- QUIC protocol used in Google's Chrome browser implements reliability in an application-layer protocol on top of UDP

### UDP Segment Structure

- Application data occupies the data field of the UDP segment
- UDP headers have 4 fields, consisting of two bytes
- Checksum is used by receiving host to verify the data

<img src="/images/Pasted image 20251215010224.png" alt="image" width="500">
### UDP Checksum

- Checksum determines whether bits within the UDP segment have been altered
- Sender performs 1s complement of the sum of all 16-bit words in the segment

<img src="/images/Pasted image 20251215010419.png" alt="image" width="500">

- Last addition had overflow, which was wrapped around
- End-end principle in system design, which states that since certain functionality must be implemented on an end-end basis

## Principles and Reliable Data Transfer

- With a reliable channel, no transferred data bits are corrupted or lost
- Reliable data transfer protocol to implement this service abstraction
- TCP is a reliable data transfer protocol that is implemented on top of an unreliable (IP) end-to-end network layer

<img src="/images/Pasted image 20251215010840.png" alt="image" width="500">

- Assume that packets will be delivered in the order that they are send
- Sending side, will pass data to upper layer
- Only consider the case of unidirectional data transfer
	- Data from sending to receiving side
- Reliable bidirectional (full-duplex) data transfer is no more difficult

### Building a Reliable Data Transfer Protocol

**Reliable Data Transfer over a Perfectly Reliable Channel: `rtd1.0`**
- The finite-state machine (FSM) definition for the `rtd1.0` sender and receiver
- No packet loss, not bit errors, and no reordring

<img src="/images/Pasted image 20251215011257.png" alt="image" width="500">

**Reliable Data Transfer over a Channel with Bit Errors: `rdt2.0**
- More realistic model of underlying channel is one in which bits in a packet may be corrupted
- Introduces checksums and ACK/NAK feedback so sender can retransmit corrupted packets
- Message-dictation protocol uses both positive and negative acknowledgements
- Retransmission protocols are also known as AQR (Automatic Repeat reQuest) protocols
	- Error detection
	- Receiver feedback
	- Retransmission

<img src="/images/Pasted image 20251215011714.png" alt="image" width="500">




- ACK or NAK packet could be corrupted
- Cannot recover from errors in ACK and NAK packets
	- Ask for a replay
	- Add checksum to recover from bit errors
	- Sender to resend current data packet
		- Introduces duplicate packets

- A simple solution is to add a new fields by putting a sequence number in this field

**`rtd2.1`**

- Adds sequence number (0 and 1) so the sender and receiver can detect duplicates

<img src="/images/Pasted image 20251215011946.png" alt="image" width="500">

<img src="/images/Pasted image 20251215012001.png" alt="image" width="500">

**`rtd2.2`**
- NAKs are removed
- Relies on ACKs with sequence numbers

<img src="/images/Pasted image 20251215012105.png" alt="image" width="500">



<img src="/images/Pasted image 20251215012049.png" alt="image" width="500">


**Reliable Data Transfer over a Lossy Channel with Bit Errors, `rdt3.0`**

- Complete reliable data transfer that can have bit errors and packet loss
- Time-based retransmission mechanism requires a countdown time that can interrupt the sender
- Sender
	- Starts the timer for each packets
	- Repsonds to a timer interrupt
	- Stops the timer
- `rtd3.0` is sometimes referred to as the alternating-bit protocol using 0 and 1s

<img src="/images/Pasted image 20251215012410.png" alt="image" width="500">



### Pipelined Reliable Data Transfer Protocols

- Problem with `rtd3.0` is the stop-and-wait protocol

<img src="/images/Pasted image 20251215012824.png" alt="image" width="500">
<img src="/images/Pasted image 20251215012836.png" alt="image" width="500">
<img src="/images/Pasted image 20251215012851.png" alt="image" width="500">

<img src="/images/Pasted image 20251215012938.png" alt="image" width="500">

- Rather than operate in a stop-and-wait manner, the sender is allowed to send multiple packets without waiting for acknowledgements
- This is known as pipelining
	- Range of sequence numbers must be increased
	- Sender and receiver sides of the protocol may have to buffer more than one packet
	- Range of sequence numbers needed and buffering requirements depend on data transport protocol
		- Go-Back-N
		- Selective repeat

### Go-Back-N (GBN)

- Sender is allowed to transport multiple packets
- Constrained to a max

<img src="/images/Pasted image 20251215013223.png" alt="image" width="500">

- $N$ is referred to as the window size, and the GBN protocol is a sliding-window protocol
- Flow control is one reason to impose a limit on the sender


<img src="/images/Pasted image 20251215013400.png" alt="image" width="500">

- Sender can have up to N unacknowledged packets in flight
- Receiver only accepts packets in order
- ACKs are cumulative
- Loss or timeout, sender must retransmit all unACKed packets

GBN sender must respond to 3 types of events
- Invocation from above
- Receipt of an ACK
- A timeout event

- Event-based programming, procedures are called (invoked) by other procedures in the stack, or are interrupted

![[Pasted image 20251215013725.png]]



### Selective Repeat (SR)

- page 265

## Connection-Oriented Transport (TCP)

### The TCP Connection

### TCP Segment Structure

### Round-Trip Time Estimation and Timeout

### Reliable Data Transfer

### Flow Control

### TCP Connection Management

## Principles of Congestion Control


### The Causes and the Costs of Congestion

### Approaches to Congestion Control

## TCP Congestion Control

### Fairness

### Explicit Congestion Notification (ECN): Network-assisted Congestion Control

## Summary